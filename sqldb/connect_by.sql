-- 계층형 조회 (CONNECT BY)
CREATE TABLE TAB1(
    C1 VARCHAR2(1),
    C2 VARCHAR2(1),
    C3 VARCHAR2(1)
);

INSERT INTO TAB1 VALUES ('1', NULL, 'A');
INSERT INTO TAB1 VALUES ('2', 1, 'B');
INSERT INTO TAB1 VALUES ('3', 1, 'C');
INSERT INTO TAB1 VALUES ('4', 2, 'D');

SELECT * FROM TAB1;


-- 계층형쿼리
CREATE TABLE FAMILY (
    FAMILY_ID   NUMBER,
    FAMILY_NAME VARCHAR(15),
    PARENT_ID   NUMBER
);

INSERT INTO FAMILY VALUES (1, '할머니', NULL);
INSERT INTO FAMILY VALUES (2, '아빠', 3);
INSERT INTO FAMILY VALUES (3, '할아버지', NULL);
INSERT INTO FAMILY VALUES (4, '엄마', 1);
INSERT INTO FAMILY VALUES (5, '딸', 4);
INSERT INTO FAMILY VALUES (6, '아들', 2);


COMMIT;
SELECT * FROM FAMILY;

-- 역방향으로 검색됨 (올라가서 찾으면) : PRIOR 부모 = 자식 
SELECT FAMILY_ID, FAMILY_NAME, PARENT_ID
FROM FAMILY
START WITH PARENT_ID =4
-- CONNECT BY FAMILY_ID = PRIOR PARENT_ID;
CONNECT BY PRIOR PARENT_ID = FAMILY_ID ;

-- 순방향으로 검색됨 (내려와서 찾으면) : PRIOR 자식 = 부모
SELECT FAMILY_ID, FAMILY_NAME, PARENT_ID
FROM FAMILY
START WITH FAMILY_ID =4
-- CONNECT BY FAMILY_ID = PRIOR PARENT_ID;
CONNECT BY PRIOR FAMILY_ID = PARENT_ID ;



/*
5 딸 4
4 엄마 1 
1 할머니 NULL
*/

-- DELETE FROM FAMILY WHERE FAMILY ID =1;
-- COMMIT;



--상위 계층인 PARENT / NULL 찾기 쉬움

--  PARENT_ID 상위컬럼 부모 / FAMILY_ID 하위컬럼 자식

SELECT * FROM FAMILY
-- PARENT_ID 4에서 시작
    START WITH PARENT_ID = 4
-- 이전 PARENT_ID와 FAMILY_ID가 같은 (조인조건)
    CONNECT BY FAMILY_ID = PRIOR PARENT_ID;
    
/*
5 딸 4
4 엄마 1
1 할머니 NULL
*/

-- 계층형 조회2
CREATE TABLE ORG_INFO(
    DEPT_CODE   VARCHAR(3),
    DEPT_NAME   VARCHAR(20),
    PARENT_DEPT VARCHAR(3)
);

INSERT INTO ORG_INFO VALUES ('100', '이과계열', NULL);
INSERT INTO ORG_INFO VALUES ('110', '공학', '100');
INSERT INTO ORG_INFO VALUES ('111', '컴퓨터', '110');
INSERT INTO ORG_INFO VALUES ('112', '전기전자', '110');
INSERT INTO ORG_INFO VALUES ('113', '건축', '110');
INSERT INTO ORG_INFO VALUES ('120', '자연', '100');
INSERT INTO ORG_INFO VALUES ('121', '생물', '120');
INSERT INTO ORG_INFO VALUES ('122', '화학', '120');
INSERT INTO ORG_INFO VALUES ('121', '물리', '120');

SELECT * FROM ORG_INFO;


-- SYS_CONNECT_BY_PATH 루트 노드부터 현재 노드까지의 경로를 검색 LEVEL, 학과 이름 검색 

SELECT LEVEL,
       SYS_CONNECT_BY_PATH (DEPT_NAME, '>') AS ORG,
       CONNECT_BY_ROOT DEPT_NAME AS ROOT,
       CONNECT_BY_ROOT DEPT_CODE AS ROOT2,
       CONNECT_BY_ISLEAF AS 학과 -- 맨 하위노드 (1로 출력됨)
    FROM ORG_INFO
    START WITH PARENT_DEPT IS NULL
    CONNECT BY PRIOR DEPT_CODE = PARENT_DEPT;
    
    




